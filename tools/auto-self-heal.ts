#!/usr/bin/env ts-node
import { Octokit } from '@octokit/rest';
import { execSync } from 'child_process';

const GITHUB_TOKEN = process.env.GITHUB_TOKEN;
const REPOSITORY = process.env.GITHUB_REPOSITORY;
const BRANCH_FIX = process.env.GH_BRANCH_FIX || 'ai-fix';
const BRANCH_MAIN = process.env.GH_BRANCH_MAIN || 'main';

if (!GITHUB_TOKEN || !REPOSITORY) {
  console.error('Missing env: GITHUB_TOKEN, GITHUB_REPOSITORY');
  process.exit(1);
}

const [OWNER, REPO] = REPOSITORY.split('/');
const octokit = new Octokit({ auth: GITHUB_TOKEN });

function getRepoActionsSettingsUrl(owner: string, repo: string): string {
  return `https://github.com/${owner}/${repo}/settings/actions`;
}

function looksLikeActionsPrCreationBlocked(err: any): boolean {
  const status = err?.status;
  const msg = String(err?.message || '');
  const apiMsg = String(err?.response?.data?.message || '');
  const combined = `${msg}\n${apiMsg}`.toLowerCase();
  return (
    status === 403 &&
    combined.includes('not permitted to create or approve pull requests')
  );
}

function run(cmd: string): string {
  return execSync(cmd, { encoding: 'utf8' }).trim();
}

function listChangedFilesAgainstMain(): string[] {
  run('git fetch origin --quiet');
  const out = run(`git diff --name-only origin/${BRANCH_MAIN}...HEAD`);
  return out ? out.split(/\r?\n/).filter(Boolean) : [];
}

function enforceAllowedPaths(files: string[]) {
  const allowed = (f: string) =>
    f.startsWith('tests/') ||
    f === 'playwright.config.ts' ||
    f === '.github/workflows/agent-engine.yml' ||
    f === '.github/workflows/backend-setup.yml';

  const blocked = files.filter((f) => !allowed(f));
  if (blocked.length > 0) {
    console.error('Disallowed files changed by self-heal:', blocked.join(', '));
    process.exit(2);
  }
}

async function ensurePullRequest() {
  const prs = await octokit.pulls.list({
    owner: OWNER,
    repo: REPO,
    head: `${OWNER}:${BRANCH_FIX}`,
    base: BRANCH_MAIN,
    state: 'open',
    per_page: 1,
  });

  const runUrl = process.env.GITHUB_RUN_ID
    ? `https://github.com/${OWNER}/${REPO}/actions/runs/${process.env.GITHUB_RUN_ID}`
    : undefined;

  const title = '[AI] Self-heal: automated fixes';
  const body = [
    'Automated self-heal changes generated by CI.',
    runUrl ? `Source run: ${runUrl}` : undefined,
    '',
    'Safety: changes restricted to tests and CI files.',
  ]
    .filter(Boolean)
    .join('\n');

  if (prs.data.length === 0) {
    await octokit.pulls.create({
      owner: OWNER,
      repo: REPO,
      head: BRANCH_FIX,
      base: BRANCH_MAIN,
      title,
      body,
    });
    console.log(`Created PR from ${BRANCH_FIX} to ${BRANCH_MAIN}`);
    return;
  }

  const pr = prs.data[0];
  await octokit.pulls.update({
    owner: OWNER,
    repo: REPO,
    pull_number: pr.number,
    title,
    body,
  });
  console.log(`Updated PR #${pr.number}`);
}

async function main() {
  const changed = listChangedFilesAgainstMain();
  if (changed.length === 0) {
    console.log('No changes detected on ai-fix; nothing to supervise.');
    return;
  }
  enforceAllowedPaths(changed);
  await ensurePullRequest();
}

main().catch((err) => {
  if (looksLikeActionsPrCreationBlocked(err)) {
    console.error(
      [
        'PR creation is blocked for the built-in GITHUB_TOKEN.',
        'Enable it in repository settings:',
        `- ${getRepoActionsSettingsUrl(OWNER, REPO)} â†’ Workflow permissions`,
        "- Select 'Read and write permissions'",
        "- Check 'Allow GitHub Actions to create and approve pull requests'",
      ].join('\n'),
    );
  }
  console.error(err);
  process.exit(1);
});
