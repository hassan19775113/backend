{"cells":[{"value":"### üìì New Notebook: `praxiapp_system`\n\n<div style=\"font-size: 12px; background-color: rgba(52, 152, 219, 0.1); border-left: 3px solid #3498db; padding: 6px 10px; margin-bottom: 15px; border-radius: 3px; color: var(--vscode-editor-foreground);\">\n    <strong>‚ÑπÔ∏è Note:</strong> Write and execute your SQL queries in the cell below.\n</div>","kind":"markdown","language":"markdown"},{"value":"WITH\nparams AS (\n    SELECT current_schema()::text AS schemaname\n),\nviews AS (\n    SELECT\n        v.schemaname,\n        v.viewname,\n        to_regclass(format('%I.%I', v.schemaname, v.viewname))::oid AS view_oid,\n        pg_get_viewdef(to_regclass(format('%I.%I', v.schemaname, v.viewname)), true) AS view_definition\n    FROM\n        pg_views v\n    JOIN\n        params p ON p.schemaname = v.schemaname\n),\ncol_counts AS (\n    SELECT\n        a.attrelid AS view_oid,\n        COUNT(*)::int AS column_count\n    FROM\n        pg_attribute a\n    JOIN\n        views v ON v.view_oid = a.attrelid\n    WHERE\n        a.attnum > 0\n        AND NOT a.attisdropped\n    GROUP BY\n        a.attrelid\n),\ndefs AS (\n    SELECT\n        v.*,\n        lower(v.view_definition) AS def_lc\n    FROM\n        views v\n),\nheuristics AS (\n    SELECT\n        d.*,\n        COALESCE((SELECT COUNT(*) FROM regexp_matches(d.def_lc, '\\mjoin\\M', 'g')), 0)::int AS join_count,\n        GREATEST(COALESCE((SELECT COUNT(*) FROM regexp_matches(d.def_lc, '\\mselect\\M', 'g')), 0) - 1, 0)::int AS subquery_count,\n        (\n            COALESCE((SELECT COUNT(*) FROM regexp_matches(d.def_lc, '\\mgroup\\s+by\\M', 'g')), 0)\n            + COALESCE((SELECT COUNT(*) FROM regexp_matches(d.def_lc, '\\mdistinct\\M', 'g')), 0)\n            + COALESCE((SELECT COUNT(*) FROM regexp_matches(d.def_lc, '\\m(sum|count|avg|min|max|array_agg|string_agg|json_agg|jsonb_agg)\\s*\\(', 'g')), 0)\n            + COALESCE((SELECT COUNT(*) FROM regexp_matches(d.def_lc, '\\mover\\s*\\(', 'g')), 0)\n        )::int AS aggregation_score,\n        (d.def_lc ~ '\\mwhere\\M') AS has_where,\n        (d.def_lc ~ '\\mgroup\\s+by\\M') AS has_group_by,\n        (d.def_lc ~ '\\mdistinct\\M') AS has_distinct\n    FROM\n        defs d\n),\nview_to_view AS (\n    SELECT\n        d.objid AS view_oid,\n        d.refobjid AS ref_view_oid\n    FROM\n        pg_depend d\n    JOIN\n        pg_class c ON c.oid = d.objid\n    JOIN\n        pg_class rc ON rc.oid = d.refobjid\n    WHERE\n        c.relkind = 'v'\n        AND rc.relkind = 'v'\n),\nview_nesting AS (\n    WITH RECURSIVE walk AS (\n        SELECT\n            v.view_oid AS root_view_oid,\n            v.view_oid AS current_view_oid,\n            0::int AS depth\n        FROM\n            heuristics v\n        UNION ALL\n        SELECT\n            w.root_view_oid,\n            vv.ref_view_oid AS current_view_oid,\n            w.depth + 1\n        FROM\n            walk w\n        JOIN\n            view_to_view vv ON vv.view_oid = w.current_view_oid\n        WHERE\n            w.depth < 25\n    )\n    SELECT\n        root_view_oid AS view_oid,\n        MAX(depth) AS nested_depth\n    FROM\n        walk\n    GROUP BY\n        root_view_oid\n),\nbase_tables AS (\n    SELECT\n        d.objid AS view_oid,\n        d.refobjid AS table_oid,\n        c.relname AS table_name\n    FROM\n        pg_depend d\n    JOIN\n        pg_class c ON c.oid = d.refobjid\n    WHERE\n        c.relkind = 'r'\n),\ntable_index_counts AS (\n    SELECT\n        bt.view_oid,\n        bt.table_oid,\n        bt.table_name,\n        COALESCE((\n            SELECT COUNT(*)::int\n            FROM pg_index i\n            WHERE i.indrelid = bt.table_oid\n        ), 0) AS index_count\n    FROM\n        base_tables bt\n),\nfinal AS (\n    SELECT\n        h.schemaname,\n        h.viewname,\n        h.view_oid,\n        h.view_definition,\n        COALESCE(cc.column_count, 0) AS column_count,\n        h.join_count,\n        h.subquery_count,\n        h.aggregation_score,\n        COALESCE(vn.nested_depth, 0) AS nested_depth,\n        (COALESCE(vn.nested_depth, 0) > 0) AS is_nested,\n        h.has_where,\n        (h.has_group_by OR h.aggregation_score > 0 OR h.has_distinct) AS is_materializable,\n        (\n            h.join_count >= 4\n            OR h.subquery_count >= 2\n            OR (h.aggregation_score >= 2 AND NOT h.has_where)\n            OR (COALESCE(vn.nested_depth, 0) >= 2)\n            OR (h.join_count >= 2 AND NOT h.has_where)\n        ) AS is_potentially_slow,\n        (\n            (h.join_count * 10)\n            + (h.subquery_count * 8)\n            + (h.aggregation_score * 6)\n            + (CASE WHEN NOT h.has_where THEN 5 ELSE 0 END)\n            + (COALESCE(vn.nested_depth, 0) * 4)\n        )::int AS cost_score\n    FROM\n        heuristics h\n    LEFT JOIN\n        col_counts cc ON cc.view_oid = h.view_oid\n    LEFT JOIN\n        view_nesting vn ON vn.view_oid = h.view_oid\n)\nSELECT\n    schemaname AS schema_name,\n    viewname   AS view_name,\n    view_definition,\n    column_count,\n    join_count,\n    subquery_count,\n    aggregation_score,\n    nested_depth,\n    is_nested,\n    is_potentially_slow,\n    is_materializable,\n    cost_score\nFROM\n    final\nORDER BY\n    cost_score DESC, view_name;","kind":"sql","language":"sql"}],"metadata":{"connectionId":"1769708345477","databaseName":"praxiapp_system","host":"localhost","port":5432,"username":"postgres","password":"postgres","custom":{"cells":[{"value":"### üìì New Notebook: `praxiapp_system`\n\n<div style=\"font-size: 12px; background-color: rgba(52, 152, 219, 0.1); border-left: 3px solid #3498db; padding: 6px 10px; margin-bottom: 15px; border-radius: 3px; color: var(--vscode-editor-foreground);\">\n    <strong>‚ÑπÔ∏è Note:</strong> Write and execute your SQL queries in the cell below.\n</div>","kind":"markdown","language":"markdown"},{"value":"WITH\nparams AS (\n    SELECT current_schema()::text AS schemaname\n),\nviews AS (\n    SELECT\n        v.schemaname,\n        v.viewname,\n        to_regclass(format('%I.%I', v.schemaname, v.viewname))::oid AS view_oid,\n        pg_get_viewdef(to_regclass(format('%I.%I', v.schemaname, v.viewname)), true) AS view_definition\n    FROM\n        pg_views v\n    JOIN\n        params p ON p.schemaname = v.schemaname\n),\ncol_counts AS (\n    SELECT\n        a.attrelid AS view_oid,\n        COUNT(*)::int AS column_count\n    FROM\n        pg_attribute a\n    JOIN\n        views v ON v.view_oid = a.attrelid\n    WHERE\n        a.attnum > 0\n        AND NOT a.attisdropped\n    GROUP BY\n        a.attrelid\n),\ndefs AS (\n    SELECT\n        v.*,\n        lower(v.view_definition) AS def_lc\n    FROM\n        views v\n),\nheuristics AS (\n    SELECT\n        d.*,\n        COALESCE((SELECT COUNT(*) FROM regexp_matches(d.def_lc, '\\mjoin\\M', 'g')), 0)::int AS join_count,\n        GREATEST(COALESCE((SELECT COUNT(*) FROM regexp_matches(d.def_lc, '\\mselect\\M', 'g')), 0) - 1, 0)::int AS subquery_count,\n        (\n            COALESCE((SELECT COUNT(*) FROM regexp_matches(d.def_lc, '\\mgroup\\s+by\\M', 'g')), 0)\n            + COALESCE((SELECT COUNT(*) FROM regexp_matches(d.def_lc, '\\mdistinct\\M', 'g')), 0)\n            + COALESCE((SELECT COUNT(*) FROM regexp_matches(d.def_lc, '\\m(sum|count|avg|min|max|array_agg|string_agg|json_agg|jsonb_agg)\\s*\\(', 'g')), 0)\n            + COALESCE((SELECT COUNT(*) FROM regexp_matches(d.def_lc, '\\mover\\s*\\(', 'g')), 0)\n        )::int AS aggregation_score,\n        (d.def_lc ~ '\\mwhere\\M') AS has_where,\n        (d.def_lc ~ '\\mgroup\\s+by\\M') AS has_group_by,\n        (d.def_lc ~ '\\mdistinct\\M') AS has_distinct\n    FROM\n        defs d\n),\nview_to_view AS (\n    SELECT\n        d.objid AS view_oid,\n        d.refobjid AS ref_view_oid\n    FROM\n        pg_depend d\n    JOIN\n        pg_class c ON c.oid = d.objid\n    JOIN\n        pg_class rc ON rc.oid = d.refobjid\n    WHERE\n        c.relkind = 'v'\n        AND rc.relkind = 'v'\n),\nview_nesting AS (\n    WITH RECURSIVE walk AS (\n        SELECT\n            v.view_oid AS root_view_oid,\n            v.view_oid AS current_view_oid,\n            0::int AS depth\n        FROM\n            heuristics v\n        UNION ALL\n        SELECT\n            w.root_view_oid,\n            vv.ref_view_oid AS current_view_oid,\n            w.depth + 1\n        FROM\n            walk w\n        JOIN\n            view_to_view vv ON vv.view_oid = w.current_view_oid\n        WHERE\n            w.depth < 25\n    )\n    SELECT\n        root_view_oid AS view_oid,\n        MAX(depth) AS nested_depth\n    FROM\n        walk\n    GROUP BY\n        root_view_oid\n),\nbase_tables AS (\n    SELECT\n        d.objid AS view_oid,\n        d.refobjid AS table_oid,\n        c.relname AS table_name\n    FROM\n        pg_depend d\n    JOIN\n        pg_class c ON c.oid = d.refobjid\n    WHERE\n        c.relkind = 'r'\n),\ntable_index_counts AS (\n    SELECT\n        bt.view_oid,\n        bt.table_oid,\n        bt.table_name,\n        COALESCE((\n            SELECT COUNT(*)::int\n            FROM pg_index i\n            WHERE i.indrelid = bt.table_oid\n        ), 0) AS index_count\n    FROM\n        base_tables bt\n),\nfinal AS (\n    SELECT\n        h.schemaname,\n        h.viewname,\n        h.view_oid,\n        h.view_definition,\n        COALESCE(cc.column_count, 0) AS column_count,\n        h.join_count,\n        h.subquery_count,\n        h.aggregation_score,\n        COALESCE(vn.nested_depth, 0) AS nested_depth,\n        (COALESCE(vn.nested_depth, 0) > 0) AS is_nested,\n        h.has_where,\n        (h.has_group_by OR h.aggregation_score > 0 OR h.has_distinct) AS is_materializable,\n        (\n            h.join_count >= 4\n            OR h.subquery_count >= 2\n            OR (h.aggregation_score >= 2 AND NOT h.has_where)\n            OR (COALESCE(vn.nested_depth, 0) >= 2)\n            OR (h.join_count >= 2 AND NOT h.has_where)\n        ) AS is_potentially_slow,\n        (\n            (h.join_count * 10)\n            + (h.subquery_count * 8)\n            + (h.aggregation_score * 6)\n            + (CASE WHEN NOT h.has_where THEN 5 ELSE 0 END)\n            + (COALESCE(vn.nested_depth, 0) * 4)\n        )::int AS cost_score\n    FROM\n        heuristics h\n    LEFT JOIN\n        col_counts cc ON cc.view_oid = h.view_oid\n    LEFT JOIN\n        view_nesting vn ON vn.view_oid = h.view_oid\n)\nSELECT\n    schemaname AS schema_name,\n    viewname   AS view_name,\n    view_definition,\n    column_count,\n    join_count,\n    subquery_count,\n    aggregation_score,\n    nested_depth,\n    is_nested,\n    is_potentially_slow,\n    is_materializable,\n    cost_score\nFROM\n    final\nORDER BY\n    cost_score DESC, view_name;","kind":"sql","language":"sql"}],"metadata":{"connectionId":"1769708345477","databaseName":"praxiapp_system","host":"localhost","port":5432,"username":"postgres","password":"postgres","custom":{"cells":[],"metadata":{"connectionId":"1769708345477","databaseName":"praxiapp_system","host":"localhost","port":5432,"username":"postgres","password":"postgres","custom":{"cells":[{"value":"### üìì New Notebook: `praxiapp_system`\n\n<div style=\"font-size: 12px; background-color: rgba(52, 152, 219, 0.1); border-left: 3px solid #3498db; padding: 6px 10px; margin-bottom: 15px; border-radius: 3px; color: var(--vscode-editor-foreground);\">\n    <strong>‚ÑπÔ∏è Note:</strong> Write and execute your SQL queries in the cell below.\n</div>","kind":"markdown","language":"markdown"},{"value":"WITH\nparams AS (\n    SELECT current_schema()::text AS schemaname\n),\nviews AS (\n    SELECT\n        v.schemaname,\n        v.viewname,\n        to_regclass(format('%I.%I', v.schemaname, v.viewname))::oid AS view_oid,\n        pg_get_viewdef(to_regclass(format('%I.%I', v.schemaname, v.viewname)), true) AS view_definition\n    FROM\n        pg_views v\n    JOIN\n        params p ON p.schemaname = v.schemaname\n),\ncol_counts AS (\n    SELECT\n        a.attrelid AS view_oid,\n        COUNT(*)::int AS column_count\n    FROM\n        pg_attribute a\n    JOIN\n        views v ON v.view_oid = a.attrelid\n    WHERE\n        a.attnum > 0\n        AND NOT a.attisdropped\n    GROUP BY\n        a.attrelid\n),\ndefs AS (\n    SELECT\n        v.*,\n        lower(v.view_definition) AS def_lc\n    FROM\n        views v\n),\nheuristics AS (\n    SELECT\n        d.*,\n        COALESCE((SELECT COUNT(*) FROM regexp_matches(d.def_lc, '\\mjoin\\M', 'g')), 0)::int AS join_count,\n        GREATEST(COALESCE((SELECT COUNT(*) FROM regexp_matches(d.def_lc, '\\mselect\\M', 'g')), 0) - 1, 0)::int AS subquery_count,\n        (\n            COALESCE((SELECT COUNT(*) FROM regexp_matches(d.def_lc, '\\mgroup\\s+by\\M', 'g')), 0)\n            + COALESCE((SELECT COUNT(*) FROM regexp_matches(d.def_lc, '\\mdistinct\\M', 'g')), 0)\n            + COALESCE((SELECT COUNT(*) FROM regexp_matches(d.def_lc, '\\m(sum|count|avg|min|max|array_agg|string_agg|json_agg|jsonb_agg)\\s*\\(', 'g')), 0)\n            + COALESCE((SELECT COUNT(*) FROM regexp_matches(d.def_lc, '\\mover\\s*\\(', 'g')), 0)\n        )::int AS aggregation_score,\n        (d.def_lc ~ '\\mwhere\\M') AS has_where,\n        (d.def_lc ~ '\\mgroup\\s+by\\M') AS has_group_by,\n        (d.def_lc ~ '\\mdistinct\\M') AS has_distinct\n    FROM\n        defs d\n),\nview_to_view AS (\n    SELECT\n        d.objid AS view_oid,\n        d.refobjid AS ref_view_oid\n    FROM\n        pg_depend d\n    JOIN\n        pg_class c ON c.oid = d.objid\n    JOIN\n        pg_class rc ON rc.oid = d.refobjid\n    WHERE\n        c.relkind = 'v'\n        AND rc.relkind = 'v'\n),\nview_nesting AS (\n    WITH RECURSIVE walk AS (\n        SELECT\n            v.view_oid AS root_view_oid,\n            v.view_oid AS current_view_oid,\n            0::int AS depth\n        FROM\n            heuristics v\n        UNION ALL\n        SELECT\n            w.root_view_oid,\n            vv.ref_view_oid AS current_view_oid,\n            w.depth + 1\n        FROM\n            walk w\n        JOIN\n            view_to_view vv ON vv.view_oid = w.current_view_oid\n        WHERE\n            w.depth < 25\n    )\n    SELECT\n        root_view_oid AS view_oid,\n        MAX(depth) AS nested_depth\n    FROM\n        walk\n    GROUP BY\n        root_view_oid\n),\nbase_tables AS (\n    SELECT\n        d.objid AS view_oid,\n        d.refobjid AS table_oid,\n        c.relname AS table_name\n    FROM\n        pg_depend d\n    JOIN\n        pg_class c ON c.oid = d.refobjid\n    WHERE\n        c.relkind = 'r'\n),\ntable_index_counts AS (\n    SELECT\n        bt.view_oid,\n        bt.table_oid,\n        bt.table_name,\n        COALESCE((\n            SELECT COUNT(*)::int\n            FROM pg_index i\n            WHERE i.indrelid = bt.table_oid\n        ), 0) AS index_count\n    FROM\n        base_tables bt\n),\nfinal AS (\n    SELECT\n        h.schemaname,\n        h.viewname,\n        h.view_oid,\n        h.view_definition,\n        COALESCE(cc.column_count, 0) AS column_count,\n        h.join_count,\n        h.subquery_count,\n        h.aggregation_score,\n        COALESCE(vn.nested_depth, 0) AS nested_depth,\n        (COALESCE(vn.nested_depth, 0) > 0) AS is_nested,\n        h.has_where,\n        (h.has_group_by OR h.aggregation_score > 0 OR h.has_distinct) AS is_materializable,\n        (\n            h.join_count >= 4\n            OR h.subquery_count >= 2\n            OR (h.aggregation_score >= 2 AND NOT h.has_where)\n            OR (COALESCE(vn.nested_depth, 0) >= 2)\n            OR (h.join_count >= 2 AND NOT h.has_where)\n        ) AS is_potentially_slow,\n        (\n            (h.join_count * 10)\n            + (h.subquery_count * 8)\n            + (h.aggregation_score * 6)\n            + (CASE WHEN NOT h.has_where THEN 5 ELSE 0 END)\n            + (COALESCE(vn.nested_depth, 0) * 4)\n        )::int AS cost_score\n    FROM\n        heuristics h\n    LEFT JOIN\n        col_counts cc ON cc.view_oid = h.view_oid\n    LEFT JOIN\n        view_nesting vn ON vn.view_oid = h.view_oid\n)\nSELECT\n    schemaname AS schema_name,\n    viewname   AS view_name,\n    view_definition,\n    column_count,\n    join_count,\n    subquery_count,\n    aggregation_score,\n    nested_depth,\n    is_nested,\n    is_potentially_slow,\n    is_materializable,\n    cost_score\nFROM\n    final\nORDER BY\n    cost_score DESC, view_name;","kind":"sql","language":"sql"}],"metadata":{"connectionId":"1769708345477","databaseName":"praxiapp_system","host":"localhost","port":5432,"username":"postgres","password":"postgres","custom":{"cells":[],"metadata":{"connectionId":"1769708345477","databaseName":"praxiapp_system","host":"localhost","port":5432,"username":"postgres","password":"postgres","enableScripts":true}},"enableScripts":true}},"enableScripts":true}},"enableScripts":true}}}}